# R programming - week 3 - markdown

## Apply Functions 

### Overview of apply functions 

* *lapply* - Loop over a list and evaluate a function on each element
* *sapply* - Same as above but tries to simplify result
* *apply* - Apply a function over the margins of an array 
* *tapply* - Apply a function over subsets of a vector (table-apply)
* *mapply* - Multivariate version of lapply 

*Object Type* | *Instantiation* | *Dimension* | *Names attr* | *Others*
--------------|-----------------|--------------|---------|---------
vector        |```vector(mode="numeric",length=10) ```| NULL | names(x) | NA
lists         |```list("a", 1+2.1i, 2.1, 2, T, c("a","b")) ```| NULL | names(x) | NA
factors       |```factor(c("yes", "yes","no","yes"), levels = c("yes","no")))```| NULL | names(x) | _levels_ defines the names/order of factor, _table_ tabulates by cross-classifying factors, _unclass_ shows underlying nos. 
matrix        |```matrix(1:10, nrow=5, ncol=2)```| _dim_ a list of 2 char vectors to set & get; nrow/ncol to get | _dimnames_ | _rbind_, _cbind_
data.frame    |```data.frame(column1 = c("a","b","c"), column2 = 3:5)```| _dim_ a list of 2 char vectors to set & get; nrow/ncol to get | _names_ and _row.names_ | _rbind_, _cbind_


### lapply and sapply
* *lapply* takes or coerces _x_ into a list and returns a list 
* *sapply* tries to make the output more relevant e.g., converting a list of scalars into a vector, a list of equal length vectors into a matrix etc. _Simplify_ argument provides some control  
* Very important to understand how coercion between lists/vectors happens here 
    * *list* - Each arg. to list() becomes 1 list element
    * *as.list()* - Each of element of vector becomes 1 element of list
    * *c()* - Each element is converted to list - implicit as.list() - and appended to              previous
* rowMeans, colMeans, rowSums, colSums are more efficient then lapply with mean/sum
* You can pass data.frames as-is (i.e. without coercion) to lapply as they are also a type of list
* *vapply* is like *sapply* but explicitly requires an expected output format e.g., ```numeric(1)``` as the 3rd arg. Throws an error otherwise. Useful for tighter control.  

### apply 
* *apply* - ```apply(x,MARGIN, FUN, ...)``` margins are basically the dimensions we want to keep expressed as a vector e.g., 1 or 2 or c(1,2). The function is applied on the array generated by fixing these dimensions 
* The dimensions you give during the function call will be retained
* If only 1 dimension is given in MARGIN and function returns a scalar then the result is a vector
* Else result is an array or matrix
* If a function return a vector, then the result (vector) for 1 iteration corresponds to 1 of the resulting array

### mapply and tapply and split 
* *mapply* - Helps to instantly vectorize a function which only takes scalar inputs e.g.
```mapply(rep,1:4,4:1)``` instead of ```list(rep(1,4),rep(2,3),rep(3,2),rep(4,1))```
* *tapply* - Summarizes over the different levels of a factor vector passed to the function
* *split* - Does not summarize but just splits the vector into different parts (for each level of factor). The returned value is a list with each element corresponding to 1 level
* If you pass multiple factor vectors to split, it will automatically run interaction inside it 

## Debugging 

* The key types of notifications in increasing order of seriousness are
    * *message()* 
    * *warning()*
    * *error()* -- this stops execution 
* *condition* - this is a more general version of notifications. All the above are different types of notification
* The key debugging functions are 
    * *debug* and *browse*. Browse just tells you from where in the function should the debugging start 
    * *traceback*
    * *recover* - You can sent options(error = recover) to "catch" errors and start an interactive session 
    * *trace* in another such function - allows you to insert debugging code into a function (even if you are not the creator). Usually the code inserted is browser 

